## scanf函数

### scanf是怎么从缓冲区读取数据的？

标准库I/O提供了三种缓冲类型：全缓冲，行缓冲，无缓冲

|            |                                                              |                                        |
| ---------- | ------------------------------------------------------------ | -------------------------------------- |
| **全缓冲** | 当缓冲区被填满或者数据读取至末尾时，执行IO操作               | 磁盘文件的读写                         |
| **行缓冲** | 当输入输出过程遇到换行符“\n” 或者分配的缓冲区已满，则执行IO操作 | 涉及终端的读写操作如：stdin/stout      |
| **无缓冲** | 当有数据产生时，立刻由相应设备进行处理                       | 一般stderr使用无缓冲，不代表系统不缓存 |


标准输入缓冲区stdin使用行缓冲的方式存储输入（接收写入设备的数据存到缓冲区中），用户存入的数据先存在临时缓冲区中，当用户键入回车或者分配的缓冲区满了之后，再执行IO操作，将数据由临时缓冲区拷贝到stdin中，比如说C语言中提供的scanf和getchar等函数就是从上述的缓冲区中读取数据

缓冲区就好像一个有大小的队列，从外界设备键入数据，将这个数据按顺序放入这个队列，然后使用getchar等函数将这个数据依次读取，（注意：因为getchar函数是读取一个字符，所以如果用户一次键入了很多数据，后面再调用getchar函数就会从缓冲区中直接读取，不需要再等待用户键入数据，直到缓冲区中的数据读取完毕）

scanf与getchar等函数会在stdin中读取数据，如果缓冲区中存在数据则直接从缓冲区中读取数据
，如果上述缓冲区为空，则将上述函数挂起，等待数据缓冲完成（键入回车或者数据缓冲区满后，stdin会进行数据缓冲），当用户一次输入的数据大于scanf，getchar等函数一次读取的数据时，剩余的数据会放在缓冲区中，之后的scanf,getchar等函数调用会直接从缓冲区中读取，不需等待用户输入，直到缓冲区中的数据被读取完之后，再等待stdin数据缓冲

### scanf函数从缓冲区读取数据的流程

格式化字符串(format string)　　
　　格式化字符串规定了 scanf 等函数如何从输入缓冲 stdin 中读取数据，其组成字符的含义如下所示：

空白字符(whitespace)**。scanf 会读取并忽略在 stdin 中下一个非空白字符之前的所有空白字符(空格、换行和 tab)，然后读取格式化字符串中规定格式的数据。**若格式化字符串中包含空白字符，则该空白字符会与输入缓冲区中任意数量的连续空白字符相匹配，并将其从缓冲区中清除(包括0个)。例如格式化字符串"%d %d"，会要求 scanf 首先从缓冲区中读取一个整型(若之前存在空白字符则跳过)，再跳过输入缓冲区中连续的空白字符(与格式化字符串中的空白字符匹配)，最后再读取一个整形

非空白字符(non whitespace)。对于格式化字符串中既非空白字符又不是格式说明符(format specifier,由%标识)的一部分的字符，scanf 会尝试从 stdin 中读取输入，并将输入与该字符比较，若匹配，则继续进行后续读取，若不匹配，则函数返回错误信息，例如：scanf("%s,%d",&a,&b)，scanf先读取一个字符串，然后读取一个’ , ‘，如果不是’ , ‘则报错返回，如果为’ , '则继续读取一个整数

格式说明符。以 % 开头的用于指定输入数据格式的字符。如 %d 指定需要读取一个整形，%s 需要读取一个字符串。scanf 等函数首先根据格式说明符尝试去解析 stdin 中的数据，如对于 %d ，scanf 会尝试对 stdin 中已有数据以整型的格式进行解析。若解析成功，则将上述解析结果存放到指定的内存中，若解析失败，如 stdin 中仅存在一个字符 ‘a’，scanf 会退出并返回，但是上述不匹配的数据并不会从缓冲区中清除，后续的 scanf 调用仍从上述输入开始读取


利用scanf行缓冲的特点，如下例子：

```cpp
#include<stdio.h>

int main(){
    char str[100];
/* 在黑框中手动输入时，系统并不知道什么时候到达了所谓的“文件末尾“，
因此需要用< Ctrl + Z >组合键，然后按< Enter >键的方式,来告诉系统已经到了EOF，
这样系统才会结束 while循环 */
    while(scanf("%s", str) != EOF){ 
        printf("%s\n", str);
    }                          
    return 0;
}
```

如果输入“who are you?”

则会以空白字字符为分割，读取三次，也就是while会循环三次。

> EOF(end of file)就是文件的结束，通常来判断文件的操作是否结束的标志。
>
> EOF不是特殊字符，而是定义在头文件<stdio.h>的常量，一般等于-1；
>
> EOF的值其实就是-1,当scanf读取内容发生错误或者读到文件结尾的时候就会返回EOF，那个while的意思就是说当当前输入缓存还有东西时就一直读取，直到输入缓存中的内容为空时停止。
>
> Windows中，Ctrl-Z表示EOF。 
>
> Linux中，在新的一行的开头，按下Ctrl-D，就代表EOF（如果在一行的中间按下Ctrl-D，则表示输出“标准输入”的缓存区，所以这时必须按两次Ctrl-D）；